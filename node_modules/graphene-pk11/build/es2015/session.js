import * as core from "./core";
import { Mechanism } from './mech';
import { SessionObject, SessionObjectCollection, ObjectClass } from "./object";
import * as objects from "./objects";
import { Key, SecretKey } from './objects';
import { Template } from "./template";
import { Cipher, Decipher, Digest, Sign, Verify } from "./crypto";
import { prepareError } from "./error";
export var SessionFlag;
(function (SessionFlag) {
    SessionFlag[SessionFlag["RW_SESSION"] = 2] = "RW_SESSION";
    SessionFlag[SessionFlag["SERIAL_SESSION"] = 4] = "SERIAL_SESSION";
})(SessionFlag || (SessionFlag = {}));
export var UserType;
(function (UserType) {
    UserType[UserType["SO"] = 0] = "SO";
    UserType[UserType["USER"] = 1] = "USER";
    UserType[UserType["CONTEXT_SPECIFIC"] = 2] = "CONTEXT_SPECIFIC";
})(UserType || (UserType = {}));
export class Session extends core.HandleObject {
    constructor(handle, slot, lib) {
        super(handle, lib);
        this.slot = slot;
        this.getInfo();
    }
    close() {
        this.lib.C_CloseSession(this.handle);
    }
    initPin(pin) {
        this.lib.C_InitPIN(this.handle, pin);
    }
    setPin(oldPin, newPin) {
        this.lib.C_SetPIN(this.handle, oldPin, newPin);
    }
    getOperationState() {
        throw new Error("Not implemented");
    }
    setOperationState(state, encryptionKey = 0, authenticationKey = 0) {
        throw new Error("Not implemented");
    }
    login(pin, userType = UserType.USER) {
        this.lib.C_Login(this.handle, userType, pin);
    }
    logout() {
        this.lib.C_Logout(this.handle);
    }
    create(template) {
        const tmpl = Template.toPkcs11(template);
        const hObject = this.lib.C_CreateObject(this.handle, tmpl);
        return new SessionObject(hObject, this, this.lib);
    }
    copy(object, template) {
        const tmpl = Template.toPkcs11(template);
        const hObject = this.lib.C_CopyObject(this.handle, object.handle, tmpl);
        return new SessionObject(hObject, this, this.lib);
    }
    destroy(param) {
        if (param instanceof SessionObject) {
            this.lib.C_DestroyObject(this.handle, param.handle);
            return 1;
        }
        else {
            const objs = this.find(param || null);
            const removed = objs.length;
            for (let i = 0; i < objs.length; i++) {
                objs.items(i).destroy();
            }
            return removed;
        }
    }
    clear() {
        return this.destroy();
    }
    find(template = null, callback) {
        if (core.isFunction(template)) {
            callback = template;
            template = null;
        }
        const tmpl = Template.toPkcs11(template);
        this.lib.C_FindObjectsInit(this.handle, tmpl);
        const handles = [];
        try {
            while (true) {
                const hObject = this.lib.C_FindObjects(this.handle);
                if (!hObject) {
                    break;
                }
                if (callback && callback(new SessionObject(hObject, this, this.lib), handles.length) === false) {
                    break;
                }
                handles.push(hObject);
            }
        }
        catch (error) {
            this.lib.C_FindObjectsFinal(this.handle);
            throw (error);
        }
        this.lib.C_FindObjectsFinal(this.handle);
        return new SessionObjectCollection(handles, this, this.lib);
    }
    getObject(handle) {
        let res;
        this.find((obj) => {
            const compare = obj.handle.compare(handle);
            if (compare === 0) {
                res = obj;
                return false;
            }
        });
        if (res) {
            return res.toType();
        }
        else {
            return null;
        }
    }
    generateKey(mechanism, template = null, callback) {
        try {
            const pMech = Mechanism.create(mechanism);
            if (template) {
                template.class = ObjectClass.SECRET_KEY;
            }
            const pTemplate = Template.toPkcs11(template);
            if (callback) {
                this.lib.C_GenerateKey(this.handle, pMech, pTemplate, (err, hKey) => {
                    if (err) {
                        callback(err, null);
                    }
                    else {
                        const obj = new SessionObject(hKey, this, this.lib);
                        callback(null, obj.toType());
                    }
                });
            }
            else {
                const hKey = this.lib.C_GenerateKey(this.handle, pMech, pTemplate);
                const obj = new SessionObject(hKey, this, this.lib);
                return obj.toType();
            }
        }
        catch (e) {
            const error = prepareError(e);
            if (callback) {
                callback(error, null);
            }
            else {
                throw error;
            }
        }
    }
    generateKeyPair(mechanism, publicTemplate, privateTemplate, callback) {
        try {
            const pMech = Mechanism.create(mechanism);
            if (publicTemplate) {
                publicTemplate.class = ObjectClass.PUBLIC_KEY;
            }
            const pubTmpl = Template.toPkcs11(publicTemplate);
            if (privateTemplate) {
                privateTemplate.class = ObjectClass.PRIVATE_KEY;
                privateTemplate.private = true;
            }
            const prvTmpl = Template.toPkcs11(privateTemplate);
            if (callback) {
                this.lib.C_GenerateKeyPair(this.handle, pMech, pubTmpl, prvTmpl, (err, keys) => {
                    if (err) {
                        callback(err, null);
                    }
                    else {
                        if (keys) {
                            callback(null, {
                                publicKey: new objects.PublicKey(keys.publicKey, this, this.lib),
                                privateKey: new objects.PrivateKey(keys.privateKey, this, this.lib),
                            });
                        }
                    }
                });
            }
            else {
                const keys = this.lib.C_GenerateKeyPair(this.handle, pMech, pubTmpl, prvTmpl);
                return {
                    publicKey: new objects.PublicKey(keys.publicKey, this, this.lib),
                    privateKey: new objects.PrivateKey(keys.privateKey, this, this.lib),
                };
            }
        }
        catch (e) {
            const error = prepareError(e);
            if (callback) {
                callback(error, null);
            }
            else {
                throw error;
            }
        }
    }
    createSign(alg, key) {
        return new Sign(this, alg, key, this.lib);
    }
    createVerify(alg, key) {
        return new Verify(this, alg, key, this.lib);
    }
    createCipher(alg, key) {
        return new Cipher(this, alg, key, this.lib);
    }
    createDecipher(alg, key, blockSize) {
        return new Decipher(this, alg, key, blockSize || 0, this.lib);
    }
    createDigest(alg) {
        return new Digest(this, alg, this.lib);
    }
    wrapKey(alg, wrappingKey, key, callback) {
        try {
            const pMech = Mechanism.create(alg);
            let wrappedKey = Buffer.alloc(8096);
            if (callback) {
                this.lib.C_WrapKey(this.handle, pMech, wrappingKey.handle, key.handle, wrappedKey, callback);
            }
            else {
                wrappedKey = this.lib.C_WrapKey(this.handle, pMech, wrappingKey.handle, key.handle, wrappedKey);
                return wrappedKey;
            }
        }
        catch (e) {
            const error = prepareError(e);
            if (callback) {
                callback(error, null);
            }
            else {
                throw error;
            }
        }
    }
    unwrapKey(alg, unwrappingKey, wrappedKey, template, callback) {
        try {
            const pMech = Mechanism.create(alg);
            const pTemplate = Template.toPkcs11(template);
            if (callback) {
                this.lib.C_UnwrapKey(this.handle, pMech, unwrappingKey.handle, wrappedKey, pTemplate, (err, hKey) => {
                    if (err) {
                        callback(err, null);
                    }
                    else {
                        callback(null, new Key(hKey, this, this.lib));
                    }
                });
            }
            else {
                const hKey = this.lib.C_UnwrapKey(this.handle, pMech, unwrappingKey.handle, wrappedKey, pTemplate);
                return new Key(hKey, this, this.lib);
            }
        }
        catch (e) {
            const error = prepareError(e);
            if (callback) {
                callback(error, null);
            }
            else {
                throw error;
            }
        }
    }
    deriveKey(alg, baseKey, template, callback) {
        try {
            const pMech = Mechanism.create(alg);
            const pTemplate = Template.toPkcs11(template);
            if (callback) {
                this.lib.C_DeriveKey(this.handle, pMech, baseKey.handle, pTemplate, (err, hKey) => {
                    if (err) {
                        callback(err, null);
                    }
                    else {
                        callback(null, new SecretKey(hKey, this, this.lib));
                    }
                });
            }
            else {
                const hKey = this.lib.C_DeriveKey(this.handle, pMech, baseKey.handle, pTemplate);
                return new SecretKey(hKey, this, this.lib);
            }
        }
        catch (e) {
            const error = prepareError(e);
            if (callback) {
                callback(error, null);
            }
            else {
                throw error;
            }
        }
    }
    generateRandom(size) {
        const buf = Buffer.alloc(size);
        this.lib.C_GenerateRandom(this.handle, buf);
        return buf;
    }
    getInfo() {
        const info = this.lib.C_GetSessionInfo(this.handle);
        this.state = info.state;
        this.flags = info.flags;
        this.deviceError = info.deviceError;
    }
}
