import * as pkcs11 from "pkcs11js";
import * as fs from "fs";
import * as core from "./core";
import { MechanismEnum } from "./mech_enum";
import { uint64ToBuffer } from "./core";
export var MechanismFlag;
(function (MechanismFlag) {
    MechanismFlag[MechanismFlag["HW"] = pkcs11.CKF_HW] = "HW";
    MechanismFlag[MechanismFlag["ENCRYPT"] = pkcs11.CKF_ENCRYPT] = "ENCRYPT";
    MechanismFlag[MechanismFlag["DECRYPT"] = pkcs11.CKF_DECRYPT] = "DECRYPT";
    MechanismFlag[MechanismFlag["DIGEST"] = pkcs11.CKF_DIGEST] = "DIGEST";
    MechanismFlag[MechanismFlag["SIGN"] = pkcs11.CKF_SIGN] = "SIGN";
    MechanismFlag[MechanismFlag["SIGN_RECOVER"] = pkcs11.CKF_SIGN_RECOVER] = "SIGN_RECOVER";
    MechanismFlag[MechanismFlag["VERIFY"] = pkcs11.CKF_VERIFY] = "VERIFY";
    MechanismFlag[MechanismFlag["VERIFY_RECOVER"] = pkcs11.CKF_VERIFY_RECOVER] = "VERIFY_RECOVER";
    MechanismFlag[MechanismFlag["GENERATE"] = pkcs11.CKF_GENERATE] = "GENERATE";
    MechanismFlag[MechanismFlag["GENERATE_KEY_PAIR"] = pkcs11.CKF_GENERATE_KEY_PAIR] = "GENERATE_KEY_PAIR";
    MechanismFlag[MechanismFlag["WRAP"] = pkcs11.CKF_WRAP] = "WRAP";
    MechanismFlag[MechanismFlag["UNWRAP"] = pkcs11.CKF_UNWRAP] = "UNWRAP";
    MechanismFlag[MechanismFlag["DERIVE"] = pkcs11.CKF_DERIVE] = "DERIVE";
})(MechanismFlag || (MechanismFlag = {}));
export class Mechanism extends core.HandleObject {
    constructor(type, handle, slotHandle, lib) {
        super(handle, lib);
        this.type = type;
        this.slotHandle = slotHandle;
        this.getInfo();
    }
    get name() {
        return MechanismEnum[this.type] || "unknown";
    }
    static create(algorithm) {
        let res;
        let alg;
        if (core.isString(algorithm)) {
            alg = { name: algorithm, params: null };
        }
        else if (core.isNumber(algorithm)) {
            alg = { name: algorithm, params: null };
        }
        else {
            alg = algorithm;
        }
        let hAlg;
        if (core.isNumber(alg.name)) {
            hAlg = alg.name;
        }
        else {
            hAlg = MechanismEnum[alg.name.toUpperCase()];
            if (core.isEmpty(hAlg)) {
                throw new TypeError(`Unknown mechanism name '${alg.name}'`);
            }
        }
        let params = null;
        if (alg.params) {
            if (alg.params.toCKI) {
                params = alg.params.toCKI();
            }
            else {
                params = alg.params;
            }
        }
        res = {
            mechanism: hAlg,
            parameter: params,
        };
        return res;
    }
    static vendor(name, value) {
        const mechs = MechanismEnum;
        if (core.isEmpty(value)) {
            const file = fs.readFileSync(name);
            const vendor = JSON.parse(file.toString());
            for (const i in vendor) {
                const newName = i;
                const v = vendor[i];
                mechs[newName] = v;
                mechs[v] = newName;
            }
        }
        else {
            const newName = name;
            mechs[newName] = value;
            mechs[value] = newName;
        }
    }
    getInfo() {
        const info = this.lib.C_GetMechanismInfo(this.slotHandle, this.type);
        this.minKeySize = info.minKeySize;
        this.maxKeySize = info.maxKeySize;
        this.flags = info.flags;
    }
}
export class MechanismCollection extends core.Collection {
    constructor(items, slotHandle, lib) {
        super(items, lib, Mechanism);
        this.slotHandle = slotHandle;
    }
    items(index) {
        const type = this.innerItems[index];
        const handle = uint64ToBuffer(type, true);
        return new Mechanism(type, handle, this.slotHandle, this.lib);
    }
    tryGetItem(index) {
        try {
            return this.items(index);
        }
        catch (_a) {
            return null;
        }
    }
}
