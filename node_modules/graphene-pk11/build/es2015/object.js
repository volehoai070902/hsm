import { __decorate } from "tslib";
import * as pkcs11 from "pkcs11js";
import { attribute } from "./core/attribute";
import { HandleObject } from "./core/object";
import { Template } from "./template";
export var ObjectClass;
(function (ObjectClass) {
    ObjectClass[ObjectClass["DATA"] = pkcs11.CKO_DATA] = "DATA";
    ObjectClass[ObjectClass["CERTIFICATE"] = pkcs11.CKO_CERTIFICATE] = "CERTIFICATE";
    ObjectClass[ObjectClass["PUBLIC_KEY"] = pkcs11.CKO_PUBLIC_KEY] = "PUBLIC_KEY";
    ObjectClass[ObjectClass["PRIVATE_KEY"] = pkcs11.CKO_PRIVATE_KEY] = "PRIVATE_KEY";
    ObjectClass[ObjectClass["SECRET_KEY"] = pkcs11.CKO_SECRET_KEY] = "SECRET_KEY";
    ObjectClass[ObjectClass["HW_FEATURE"] = pkcs11.CKO_HW_FEATURE] = "HW_FEATURE";
    ObjectClass[ObjectClass["DOMAIN_PARAMETERS"] = pkcs11.CKO_DOMAIN_PARAMETERS] = "DOMAIN_PARAMETERS";
    ObjectClass[ObjectClass["MECHANISM"] = pkcs11.CKO_MECHANISM] = "MECHANISM";
    ObjectClass[ObjectClass["OTP_KEY"] = pkcs11.CKO_OTP_KEY] = "OTP_KEY";
})(ObjectClass || (ObjectClass = {}));
export class SessionObjectFactory {
    static register(cko, type, cb) {
        this.items.set(cko, {
            type,
            cb
        });
    }
    static create(cko, object) {
        const item = this.items.get(cko);
        if (!item) {
            throw new Error("Cannot create SessionObject. Unsupported CKO type.");
        }
        const res = new item.type(object);
        if (item.cb) {
            return item.cb(res, object);
        }
        return res;
    }
}
SessionObjectFactory.items = new Map();
export class SessionObject extends HandleObject {
    constructor(handle, session, lib) {
        if (handle instanceof SessionObject) {
            const obj = handle;
            super(obj.handle, obj.lib);
            this.session = obj.session;
        }
        else {
            super(handle, lib);
            this.session = session;
        }
    }
    get size() {
        return this.lib.C_GetObjectSize(this.session.handle, this.handle);
    }
    copy(template) {
        const tmpl = Template.toPkcs11(template);
        const hObject = this.lib.C_CopyObject(this.session.handle, this.handle, tmpl);
        return new SessionObject(hObject, this.session, this.lib);
    }
    destroy() {
        this.lib.C_DestroyObject(this.session.handle, this.handle);
    }
    getAttribute(param) {
        if (core.isNumber(param)) {
            return this.lib.C_GetAttributeValue(this.session.handle, this.handle, [
                { type: param },
            ])[0].value;
        }
        else if (core.isString(param)) {
            const res = this.lib.C_GetAttributeValue(this.session.handle, this.handle, Template.toPkcs11({ [param]: null }));
            return Template.fromPkcs11(res)[param];
        }
        const res = this.lib.C_GetAttributeValue(this.session.handle, this.handle, Template.toPkcs11(param));
        return Template.fromPkcs11(res);
    }
    setAttribute(param, value) {
        let tmpl = [];
        if (core.isNumber(param)) {
            tmpl.push({ type: param, value });
        }
        else if (core.isString(param)) {
            tmpl = Template.toPkcs11({ [param]: value });
        }
        else {
            tmpl = Template.toPkcs11(param);
        }
        this.lib.C_SetAttributeValue(this.session.handle, this.handle, tmpl);
    }
    get(param) {
        return this.getAttribute(param);
    }
    set(param, value) {
        this.setAttribute(param, value);
    }
    toType() {
        return SessionObjectFactory.create(this.class, this);
    }
    getInfo() {
    }
}
__decorate([
    attribute("class")
], SessionObject.prototype, "class", void 0);
import * as core from "./core";
export class SessionObjectCollection extends core.Collection {
    constructor(items, session, lib) {
        super(items, lib, SessionObject);
        this.session = session;
    }
    items(index) {
        return new SessionObject(this.innerItems[index], this.session, this.lib);
    }
}
