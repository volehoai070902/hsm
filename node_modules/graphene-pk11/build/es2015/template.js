import * as pkcs11 from "pkcs11js";
const TYPE_NUMBER = "number";
const TYPE_BOOL = "boolean";
const TYPE_STRING = "string";
const TYPE_BUFFER = "buffer";
const TYPE_DATE = "date";
const attribute = {
    class: { v: pkcs11.CKA_CLASS, t: TYPE_NUMBER },
    token: { v: pkcs11.CKA_TOKEN, t: TYPE_BOOL },
    private: { v: pkcs11.CKA_PRIVATE, t: TYPE_BOOL },
    label: { v: pkcs11.CKA_LABEL, t: TYPE_STRING },
    application: { v: pkcs11.CKA_APPLICATION, t: TYPE_STRING },
    value: { v: pkcs11.CKA_VALUE, t: TYPE_BUFFER },
    objectId: { v: pkcs11.CKA_OBJECT_ID, t: TYPE_BUFFER },
    certType: { v: pkcs11.CKA_CERTIFICATE_TYPE, t: TYPE_NUMBER },
    issuer: { v: pkcs11.CKA_ISSUER, t: TYPE_BUFFER },
    serial: { v: pkcs11.CKA_SERIAL_NUMBER, t: TYPE_BUFFER },
    issuerAC: { v: pkcs11.CKA_AC_ISSUER, t: TYPE_BUFFER },
    owner: { v: pkcs11.CKA_OWNER, t: TYPE_BUFFER },
    attrTypes: { v: pkcs11.CKA_ATTR_TYPES, t: TYPE_BUFFER },
    trusted: { v: pkcs11.CKA_TRUSTED, t: TYPE_BOOL },
    certCategory: { v: pkcs11.CKA_CERTIFICATE_CATEGORY, t: TYPE_NUMBER },
    javaDomain: { v: pkcs11.CKA_JAVA_MIDP_SECURITY_DOMAIN, t: TYPE_NUMBER },
    url: { v: pkcs11.CKA_URL, t: TYPE_STRING },
    ski: { v: pkcs11.CKA_HASH_OF_SUBJECT_PUBLIC_KEY, t: TYPE_BUFFER },
    aki: { v: pkcs11.CKA_HASH_OF_ISSUER_PUBLIC_KEY, t: TYPE_BUFFER },
    checkValue: { v: pkcs11.CKA_CHECK_VALUE, t: TYPE_BUFFER },
    keyType: { v: pkcs11.CKA_KEY_TYPE, t: TYPE_NUMBER },
    subject: { v: pkcs11.CKA_SUBJECT, t: TYPE_BUFFER },
    id: { v: pkcs11.CKA_ID, t: TYPE_BUFFER },
    sensitive: { v: pkcs11.CKA_SENSITIVE, t: TYPE_BOOL },
    encrypt: { v: pkcs11.CKA_ENCRYPT, t: TYPE_BOOL },
    decrypt: { v: pkcs11.CKA_DECRYPT, t: TYPE_BOOL },
    wrap: { v: pkcs11.CKA_WRAP, t: TYPE_BOOL },
    unwrap: { v: pkcs11.CKA_UNWRAP, t: TYPE_BOOL },
    sign: { v: pkcs11.CKA_SIGN, t: TYPE_BOOL },
    signRecover: { v: pkcs11.CKA_SIGN_RECOVER, t: TYPE_BOOL },
    verify: { v: pkcs11.CKA_VERIFY, t: TYPE_BOOL },
    verifyRecover: { v: pkcs11.CKA_VERIFY_RECOVER, t: TYPE_BOOL },
    derive: { v: pkcs11.CKA_DERIVE, t: TYPE_BOOL },
    startDate: { v: pkcs11.CKA_START_DATE, t: TYPE_DATE },
    endDate: { v: pkcs11.CKA_END_DATE, t: TYPE_DATE },
    modulus: { v: pkcs11.CKA_MODULUS, t: TYPE_BUFFER },
    modulusBits: { v: pkcs11.CKA_MODULUS_BITS, t: TYPE_NUMBER },
    publicExponent: { v: pkcs11.CKA_PUBLIC_EXPONENT, t: TYPE_BUFFER },
    privateExponent: { v: pkcs11.CKA_PRIVATE_EXPONENT, t: TYPE_BUFFER },
    prime1: { v: pkcs11.CKA_PRIME_1, t: TYPE_BUFFER },
    prime2: { v: pkcs11.CKA_PRIME_2, t: TYPE_BUFFER },
    exp1: { v: pkcs11.CKA_EXPONENT_1, t: TYPE_BUFFER },
    exp2: { v: pkcs11.CKA_EXPONENT_2, t: TYPE_BUFFER },
    coefficient: { v: pkcs11.CKA_COEFFICIENT, t: TYPE_BUFFER },
    prime: { v: pkcs11.CKA_PRIME, t: TYPE_BUFFER },
    subprime: { v: pkcs11.CKA_SUBPRIME, t: TYPE_BUFFER },
    base: { v: pkcs11.CKA_BASE, t: TYPE_BUFFER },
    primeBits: { v: pkcs11.CKA_PRIME_BITS, t: TYPE_NUMBER },
    subprimeBits: { v: pkcs11.CKA_SUBPRIME_BITS, t: TYPE_NUMBER },
    valueBits: { v: pkcs11.CKA_VALUE_BITS, t: TYPE_NUMBER },
    valueLen: { v: pkcs11.CKA_VALUE_LEN, t: TYPE_NUMBER },
    extractable: { v: pkcs11.CKA_EXTRACTABLE, t: TYPE_BOOL },
    local: { v: pkcs11.CKA_LOCAL, t: TYPE_BOOL },
    neverExtractable: { v: pkcs11.CKA_NEVER_EXTRACTABLE, t: TYPE_BOOL },
    alwaysSensitive: { v: pkcs11.CKA_ALWAYS_SENSITIVE, t: TYPE_BOOL },
    keyGenMechanism: { v: pkcs11.CKA_KEY_GEN_MECHANISM, t: TYPE_NUMBER },
    modifiable: { v: pkcs11.CKA_MODIFIABLE, t: TYPE_BOOL },
    paramsECDSA: { v: pkcs11.CKA_ECDSA_PARAMS, t: TYPE_BUFFER },
    paramsEC: { v: pkcs11.CKA_EC_PARAMS, t: TYPE_BUFFER },
    pointEC: { v: pkcs11.CKA_EC_POINT, t: TYPE_BUFFER },
    secondaryAuth: { v: pkcs11.CKA_SECONDARY_AUTH, t: TYPE_BOOL },
    authPinFlags: { v: pkcs11.CKA_AUTH_PIN_FLAGS, t: TYPE_NUMBER },
    alwaysAuth: { v: pkcs11.CKA_ALWAYS_AUTHENTICATE, t: TYPE_BOOL },
    wrapWithTrusted: { v: pkcs11.CKA_WRAP_WITH_TRUSTED, t: TYPE_BOOL },
    wrapTemplate: { v: pkcs11.CKA_WRAP_TEMPLATE, t: TYPE_BUFFER },
    unwrapTemplate: { v: pkcs11.CKA_UNWRAP_TEMPLATE, t: TYPE_BUFFER },
    otpFormat: { v: pkcs11.CKA_OTP_FORMAT, t: TYPE_BUFFER },
    otpLength: { v: pkcs11.CKA_OTP_LENGTH, t: TYPE_BUFFER },
    otpTimeInterval: { v: pkcs11.CKA_OTP_TIME_INTERVAL, t: TYPE_BUFFER },
    otpUserFriendlyMode: { v: pkcs11.CKA_OTP_USER_FRIENDLY_MODE, t: TYPE_BUFFER },
    otpChallengeReq: { v: pkcs11.CKA_OTP_CHALLENGE_REQUIREMENT, t: TYPE_BUFFER },
    otpTimeReq: { v: pkcs11.CKA_OTP_TIME_REQUIREMENT, t: TYPE_BUFFER },
    otpCounterReq: { v: pkcs11.CKA_OTP_COUNTER_REQUIREMENT, t: TYPE_BUFFER },
    otpPinReq: { v: pkcs11.CKA_OTP_PIN_REQUIREMENT, t: TYPE_BUFFER },
    otpCounter: { v: pkcs11.CKA_OTP_COUNTER, t: TYPE_BUFFER },
    otpTime: { v: pkcs11.CKA_OTP_TIME, t: TYPE_BUFFER },
    otpUserId: { v: pkcs11.CKA_OTP_USER_IDENTIFIER, t: TYPE_BUFFER },
    otpServiceId: { v: pkcs11.CKA_OTP_SERVICE_IDENTIFIER, t: TYPE_BUFFER },
    otpServiceLogo: { v: pkcs11.CKA_OTP_SERVICE_LOGO, t: TYPE_BUFFER },
    otpServiceLogoType: { v: pkcs11.CKA_OTP_SERVICE_LOGO_TYPE, t: TYPE_BUFFER },
    hwFeatureType: { v: pkcs11.CKA_HW_FEATURE_TYPE, t: TYPE_BUFFER },
    resetOnInit: { v: pkcs11.CKA_RESET_ON_INIT, t: TYPE_BUFFER },
    hasReset: { v: pkcs11.CKA_HAS_RESET, t: TYPE_BUFFER },
    pixelX: { v: pkcs11.CKA_PIXEL_X, t: TYPE_BUFFER },
    pixelY: { v: pkcs11.CKA_PIXEL_Y, t: TYPE_BUFFER },
    resolution: { v: pkcs11.CKA_RESOLUTION, t: TYPE_BUFFER },
    charRows: { v: pkcs11.CKA_CHAR_ROWS, t: TYPE_BUFFER },
    charCols: { v: pkcs11.CKA_CHAR_COLUMNS, t: TYPE_BUFFER },
    color: { v: pkcs11.CKA_COLOR, t: TYPE_BUFFER },
    bitsPerPixel: { v: pkcs11.CKA_BITS_PER_PIXEL, t: TYPE_BUFFER },
    charSets: { v: pkcs11.CKA_CHAR_SETS, t: TYPE_BUFFER },
    encMethod: { v: pkcs11.CKA_ENCODING_METHODS, t: TYPE_BUFFER },
    mimeTypes: { v: pkcs11.CKA_MIME_TYPES, t: TYPE_BUFFER },
    mechanismType: { v: pkcs11.CKA_MECHANISM_TYPE, t: TYPE_BUFFER },
    requiredCmsAttrs: { v: pkcs11.CKA_REQUIRED_CMS_ATTRIBUTES, t: TYPE_BUFFER },
    defaultCmsAttrs: { v: pkcs11.CKA_DEFAULT_CMS_ATTRIBUTES, t: TYPE_BUFFER },
    supportedCmsAttrs: { v: pkcs11.CKA_SUPPORTED_CMS_ATTRIBUTES, t: TYPE_BUFFER },
    allowedMechanisms: { v: pkcs11.CKA_ALLOWED_MECHANISMS, t: TYPE_BUFFER },
};
function n2i(name) {
    const attr = attribute[name];
    if (attr !== void 0 && "v" in attr) {
        return attr.v;
    }
    throw new Error(`Unsupported attribute name '${name}'. Use 'registerAttribute' to add custom attribute.`);
}
function i2n(cka) {
    for (const i in attribute) {
        const attr = attribute[i];
        if (attr && "v" in attr && attr.v === cka) {
            return i;
        }
    }
    throw new Error(`Unsupported attribute ID '${cka}'. Use 'registerAttribute' to add custom attribute.`);
}
function b2v(type, value) {
    switch (type) {
        case TYPE_NUMBER:
            return value.readUInt32LE(0);
        case TYPE_BOOL:
            return value[0] === 1;
        case TYPE_STRING:
            return value.toString();
        case TYPE_BUFFER:
            return value;
        case TYPE_DATE:
            const date = value.toString();
            return new Date(+date.slice(0, 4), +date.slice(4, 6), +date.slice(6, 8));
        default:
            throw new Error(`Unknown type in use '${type}'`);
    }
}
export function getAttribute(name) {
    for (const key in attribute) {
        if (key === name) {
            return attribute[key];
        }
    }
    throw new Error(`Unsupported attribute ID '${name}'. Use 'registerAttribute' to add custom attribute.`);
}
export class Template {
    static toPkcs11(tmpl) {
        const res = [];
        if (tmpl) {
            for (const key in tmpl) {
                const attr = getAttribute(key);
                let value = tmpl[key];
                if (attr.t === TYPE_DATE) {
                    const year = value.toLocaleDateString("en-en", { year: "numeric" });
                    const month = value.toLocaleDateString("en-en", { month: "2-digit" });
                    const day = value.toLocaleDateString("en-en", { day: "2-digit" });
                    value = `${year}${month}${day}`;
                }
                res.push({
                    type: attr.v,
                    value: tmpl[key],
                });
            }
        }
        return res;
    }
    static fromPkcs11(tmpl) {
        const res = {};
        for (const i in tmpl) {
            const attr = tmpl[i];
            const name = i2n(attr.type);
            const type = attribute[name].t;
            if (type === void 0) {
                throw new Error(`Can not get type for attribute '${name}'.`);
            }
            res[i2n(attr.type)] = b2v(type, attr.value);
        }
        return res;
    }
}
export function registerAttribute(name, value, type) {
    attribute[name] = { v: value, t: type };
}
