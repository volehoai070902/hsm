/// <reference types="node" />
import * as pkcs11 from "pkcs11js";
import * as core from "./core";
import { MechanismType } from './mech';
import { SessionObject, SessionObjectCollection } from "./object";
import * as objects from "./objects";
import { Key, SecretKey } from './objects';
import { Slot } from "./slot";
import { ITemplate } from "./template";
import { Callback } from "./types";
import { Cipher, Decipher, Digest, Sign, Verify } from "./crypto";
export declare enum SessionFlag {
    /**
     * `True` if the session is read/write; `false` if the session is read-only
     */
    RW_SESSION = 2,
    /**
     * This flag is provided for backward compatibility, and should always be set to `true`
     */
    SERIAL_SESSION = 4
}
/**
 * Enumeration specifies user types
 */
export declare enum UserType {
    /**
     * Security Officer
     */
    SO = 0,
    /**
     * User
     */
    USER = 1,
    /**
     * Context specific
     */
    CONTEXT_SPECIFIC = 2
}
/**
 * Structure of asymmetric key pair
 */
export interface IKeyPair {
    privateKey: objects.PrivateKey;
    publicKey: objects.PublicKey;
}
declare type SessionFindCallback = (obj: SessionObject, index: number) => any;
/**
 * Provides information about a session
 */
export declare class Session extends core.HandleObject {
    /**
     * Slot
     *
     * @type {Slot}
     */
    slot: Slot;
    /**
     * The state of the session
     */
    state: number;
    /**
     * Bit flags that define the type of session
     */
    flags: number;
    /**
     * An error code defined by the cryptographic device. Used for errors not covered by Cryptoki
     */
    deviceError: number;
    /**
     * Creates a new instance of {@link Session}
     * @param handle ID of slot's session
     * @param slot PKCS#11 slot
     * @param lib PKCS#11 module
     */
    constructor(handle: core.Handle, slot: Slot, lib: pkcs11.PKCS11);
    /**
     * Closes a session between an application and a token
     */
    close(): void;
    /**
     * Initializes the normal user's PIN
     * @param pin the normal user's PIN
     */
    initPin(pin: string): void;
    /**
     * modifies the PIN of the user who is logged in
     * @param oldPin The old PIN
     * @param newPin The new PIN
     */
    setPin(oldPin: string, newPin: string): void;
    /**
     * Obtains a copy of the cryptographic operations state of a session, encoded as a string of bytes
     */
    getOperationState(): Buffer;
    /**
     * Restores the cryptographic operations state of a session
     * from a string of bytes obtained with getOperationState
     * @param state the saved state
     * @param encryptionKey holds key which will be used for an ongoing encryption
     * or decryption operation in the restored session
     * (or 0 if no encryption or decryption key is needed,
     * either because no such operation is ongoing in the stored session
     * or because all the necessary key information is present in the saved state)
     * @param authenticationKey holds a handle to the key which will be used for an ongoing signature,
     * MACing, or verification operation in the restored session
     * (or 0 if no such key is needed, either because no such operation is ongoing in the stored session
     * or because all the necessary key information is present in the saved state)
     */
    setOperationState(state: Buffer, encryptionKey?: number, authenticationKey?: number): void;
    /**
     * Logs a user into a token
     * @param pin the user's PIN.
     * - This standard allows PIN values to contain any valid `UTF8` character,
     * but the token may impose subset restrictions
     * @param userType the user type. Default is {@link UserType.USER}
     */
    login(pin: string, userType?: UserType): void;
    /**
     * logs a user out from a token
     */
    logout(): void;
    /**
     * creates a new object
     * - Only session objects can be created during a read-only session.
     * - Only public objects can be created unless the normal user is logged in.
     * @param template the object's template
     * @returns The new instance of {@link SessionObject}
     */
    create(template: ITemplate): SessionObject;
    /**
     * Copies an object, creating a new object for the copy
     * @param object the copied object
     * @param template template for new object
     * @returns The new instance of {@link SessionObject}
     */
    copy(object: SessionObject, template: ITemplate): SessionObject;
    /**
     * Removes all session objects matched to template
     * @param template The list of attributes
     * @returns The number of destroyed objects
     */
    destroy(template: ITemplate): number;
    /**
     * Removes the specified session object
     * @param object Object for destroying
     * @returns  The number of destroyed objects
     */
    destroy(object: SessionObject): number;
    /**
     * Removes all session objects
     * @returns The number of destroyed objects
     */
    destroy(): number;
    /**
     * Removes all session objects
     * @returns The number of destroyed objects
     */
    clear(): number;
    /**
     * Returns a collection of session objects matched to template
     * @param template Th list of attributes
     * @param callback Optional callback function which is called for each founded object
     * - if callback function returns `false`, it breaks find function.
     * @returns Th collection of session objects
     */
    find(): SessionObjectCollection;
    find(callback: SessionFindCallback): SessionObjectCollection;
    find(template?: ITemplate | null, callback?: SessionFindCallback): SessionObjectCollection;
    /**
     * Returns object from session by handle
     * @param handle handle of object
     * @returns The session object or null
     */
    getObject<T extends SessionObject>(handle: core.Handle): T | null;
    /**
     * Generates a secret key or set of domain parameters, creating a new object.
     * @param mechanism Generation mechanism
     * @param template Template for the new key or set of domain parameters
     * @returns The secret key
     */
    generateKey(mechanism: MechanismType, template?: ITemplate): objects.SecretKey;
    /**
     * Generates a secret key or set of domain parameters, creating a new object.
     * @param mechanism Generation mechanism
     * @param template Template for the new key or set of domain parameters
     * @param callback Async callback with generated key
     */
    generateKey(mechanism: MechanismType, template: ITemplate, callback: Callback<Error, objects.SecretKey>): void;
    /**
     * Generates an asymmetric key pair
     * @param mechanism Generation mechanism
     * @param publicTemplate The public key template
     * @param privateTemplate The private key template
     * @returns The generated key pair
     */
    generateKeyPair(mechanism: MechanismType, publicTemplate: ITemplate, privateTemplate: ITemplate): IKeyPair;
    /**
     * Generates an asymmetric key pair
     * @param mechanism Generation mechanism
     * @param publicTemplate The public key template
     * @param privateTemplate The private key template
     * @param callback Async callback with generated key pair
     */
    generateKeyPair(mechanism: MechanismType, publicTemplate: ITemplate, privateTemplate: ITemplate, callback: Callback<Error, IKeyPair>): void;
    /**
     * Creates the signing operation
     * @param alg The signing mechanism
     * @param key The signing key
     * @returns Signing operation
     */
    createSign(alg: MechanismType, key: Key): Sign;
    /**
     * Creates the verifying operation
     * @param alg The verifying mechanism
     * @param key The verifying key
     */
    createVerify(alg: MechanismType, key: Key): Verify;
    /**
     * Creates the encryption operation
     * @param alg The encryption mechanism
     * @param key The encryption key
     * @returns The encryption operation
     */
    createCipher(alg: MechanismType, key: Key): Cipher;
    /**
     * Creates the decryption operation
     * @param alg The decryption mechanism
     * @param key The decryption key
     * @param blockSize Block size in bytes
     * @returns The decryption operation
     */
    createDecipher(alg: MechanismType, key: Key, blockSize?: number): Decipher;
    /**
     * Creates the digest operation
     * @param alg The digest mechanism
     * @return The digest operation
     */
    createDigest(alg: MechanismType): Digest;
    /**
     * Wraps (i.e., encrypts) a key
     * @param alg Wrapping mechanism
     * @param wrappingKey Wrapping key
     * @param key Key to be wrapped
     * @returns Wrapped key
     */
    wrapKey(alg: MechanismType, wrappingKey: Key, key: Key): Buffer;
    /**
     * Wraps (i.e., encrypts) a key
     * @param alg Wrapping mechanism
     * @param wrappingKey Wrapping key
     * @param key Key to be wrapped
     * @param callback Async callback function with wrapped key
     */
    wrapKey(alg: MechanismType, wrappingKey: Key, key: Key, callback: Callback<Error, Buffer>): void;
    /**
     * Unwraps (decrypts) a wrapped key
     * @param alg Unwrapping mechanism
     * @param unwrappingKey Unwrapping key
     * @param wrappedKey Wrapped key
     * @param template New key template
     * @returns Unwrapped key
     */
    unwrapKey(alg: MechanismType, unwrappingKey: Key, wrappedKey: Buffer, template: ITemplate): Key;
    unwrapKey(alg: MechanismType, unwrappingKey: Key, wrappedKey: Buffer, template: ITemplate, callback: Callback<Error, Key>): void;
    /**
     * Derives a key from a base key
     * @param alg Key derivation mech
     * @param baseKey Base key
     * @param template New key template
     * @returns Derived key
     */
    deriveKey(alg: MechanismType, baseKey: Key, template: ITemplate): SecretKey;
    /**
     * Derives a key from a base key
     * @param alg Key derivation mech
     * @param baseKey Base key
     * @param template New key template
     * @param callback Async callback function with derived key
     */
    deriveKey(alg: MechanismType, baseKey: Key, template: ITemplate, callback: Callback<Error, Key>): void;
    /**
     * Generates random data
     * @param size Amount of bytes to generate
     * @returns New byte array
     */
    generateRandom(size: number): Buffer;
    protected getInfo(): void;
}
export {};
