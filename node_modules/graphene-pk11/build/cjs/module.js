"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Module = void 0;
const tslib_1 = require("tslib");
const pkcs11 = tslib_1.__importStar(require("pkcs11js"));
const core = tslib_1.__importStar(require("./core"));
const error_1 = require("./error");
const slot_1 = require("./slot");
class Module extends core.BaseObject {
    constructor(lib) {
        super(lib);
        this.libFile = "";
        this.libName = "";
    }
    static load(libFile, libName) {
        const lib = new pkcs11.PKCS11();
        lib.load(libFile);
        const module = new Module(lib);
        module.libFile = libFile;
        module.libName = libName || libFile;
        return module;
    }
    initialize(options) {
        try {
            this.lib.C_Initialize(options);
        }
        catch (e) {
            const error = (0, error_1.prepareError)(e);
            if (!/CKR_CRYPTOKI_ALREADY_INITIALIZED/.test(error.message)) {
                throw error;
            }
        }
        this.getInfo();
    }
    finalize() {
        this.lib.C_Finalize();
    }
    getSlots(index, tokenPresent = true) {
        if (!core.isEmpty(index) && core.isBoolean(index)) {
            tokenPresent = index;
        }
        const arr = this.lib.C_GetSlotList(tokenPresent);
        const col = new slot_1.SlotCollection(arr, this, this.lib);
        if (core.isNumber(index)) {
            return col.items(index);
        }
        return col;
    }
    close() {
        this.lib.close();
    }
    getInfo() {
        const info = this.lib.C_GetInfo();
        this.cryptokiVersion = info.cryptokiVersion;
        this.manufacturerID = core.removePadding(info.manufacturerID);
        this.libraryDescription = core.removePadding(info.libraryDescription);
        this.flags = info.flags;
        this.libraryVersion = info.libraryVersion;
    }
}
exports.Module = Module;
