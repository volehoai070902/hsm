"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionObjectCollection = exports.SessionObject = exports.SessionObjectFactory = exports.ObjectClass = void 0;
const tslib_1 = require("tslib");
const pkcs11 = tslib_1.__importStar(require("pkcs11js"));
const attribute_1 = require("./core/attribute");
const object_1 = require("./core/object");
const template_1 = require("./template");
var ObjectClass;
(function (ObjectClass) {
    ObjectClass[ObjectClass["DATA"] = pkcs11.CKO_DATA] = "DATA";
    ObjectClass[ObjectClass["CERTIFICATE"] = pkcs11.CKO_CERTIFICATE] = "CERTIFICATE";
    ObjectClass[ObjectClass["PUBLIC_KEY"] = pkcs11.CKO_PUBLIC_KEY] = "PUBLIC_KEY";
    ObjectClass[ObjectClass["PRIVATE_KEY"] = pkcs11.CKO_PRIVATE_KEY] = "PRIVATE_KEY";
    ObjectClass[ObjectClass["SECRET_KEY"] = pkcs11.CKO_SECRET_KEY] = "SECRET_KEY";
    ObjectClass[ObjectClass["HW_FEATURE"] = pkcs11.CKO_HW_FEATURE] = "HW_FEATURE";
    ObjectClass[ObjectClass["DOMAIN_PARAMETERS"] = pkcs11.CKO_DOMAIN_PARAMETERS] = "DOMAIN_PARAMETERS";
    ObjectClass[ObjectClass["MECHANISM"] = pkcs11.CKO_MECHANISM] = "MECHANISM";
    ObjectClass[ObjectClass["OTP_KEY"] = pkcs11.CKO_OTP_KEY] = "OTP_KEY";
})(ObjectClass = exports.ObjectClass || (exports.ObjectClass = {}));
class SessionObjectFactory {
    static register(cko, type, cb) {
        this.items.set(cko, {
            type,
            cb
        });
    }
    static create(cko, object) {
        const item = this.items.get(cko);
        if (!item) {
            throw new Error("Cannot create SessionObject. Unsupported CKO type.");
        }
        const res = new item.type(object);
        if (item.cb) {
            return item.cb(res, object);
        }
        return res;
    }
}
exports.SessionObjectFactory = SessionObjectFactory;
SessionObjectFactory.items = new Map();
class SessionObject extends object_1.HandleObject {
    constructor(handle, session, lib) {
        if (handle instanceof SessionObject) {
            const obj = handle;
            super(obj.handle, obj.lib);
            this.session = obj.session;
        }
        else {
            super(handle, lib);
            this.session = session;
        }
    }
    get size() {
        return this.lib.C_GetObjectSize(this.session.handle, this.handle);
    }
    copy(template) {
        const tmpl = template_1.Template.toPkcs11(template);
        const hObject = this.lib.C_CopyObject(this.session.handle, this.handle, tmpl);
        return new SessionObject(hObject, this.session, this.lib);
    }
    destroy() {
        this.lib.C_DestroyObject(this.session.handle, this.handle);
    }
    getAttribute(param) {
        if (core.isNumber(param)) {
            return this.lib.C_GetAttributeValue(this.session.handle, this.handle, [
                { type: param },
            ])[0].value;
        }
        else if (core.isString(param)) {
            const res = this.lib.C_GetAttributeValue(this.session.handle, this.handle, template_1.Template.toPkcs11({ [param]: null }));
            return template_1.Template.fromPkcs11(res)[param];
        }
        const res = this.lib.C_GetAttributeValue(this.session.handle, this.handle, template_1.Template.toPkcs11(param));
        return template_1.Template.fromPkcs11(res);
    }
    setAttribute(param, value) {
        let tmpl = [];
        if (core.isNumber(param)) {
            tmpl.push({ type: param, value });
        }
        else if (core.isString(param)) {
            tmpl = template_1.Template.toPkcs11({ [param]: value });
        }
        else {
            tmpl = template_1.Template.toPkcs11(param);
        }
        this.lib.C_SetAttributeValue(this.session.handle, this.handle, tmpl);
    }
    get(param) {
        return this.getAttribute(param);
    }
    set(param, value) {
        this.setAttribute(param, value);
    }
    toType() {
        return SessionObjectFactory.create(this.class, this);
    }
    getInfo() {
    }
}
tslib_1.__decorate([
    (0, attribute_1.attribute)("class")
], SessionObject.prototype, "class", void 0);
exports.SessionObject = SessionObject;
const core = tslib_1.__importStar(require("./core"));
class SessionObjectCollection extends core.Collection {
    constructor(items, session, lib) {
        super(items, lib, SessionObject);
        this.session = session;
    }
    items(index) {
        return new SessionObject(this.innerItems[index], this.session, this.lib);
    }
}
exports.SessionObjectCollection = SessionObjectCollection;
